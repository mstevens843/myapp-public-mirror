generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id               String     @id @default(uuid()) // User's unique ID
  activeWalletId   Int?                                // FK to one of the user's wallets
  type             String     @default("telegram")
  userId           String     @unique                // Renamed externalId to userId
  username         String?    @unique                // Added username field
  hashedPassword   String?
  email            String?    @unique
  createdAt        DateTime   @default(now())
  wallets          Wallet[]   @relation("UserWallets") // Relation to multiple wallets
  telegramPreferences TelegramPreference[]
  userPreferences   UserPreference[]
  dcaOrders         DcaOrder[]
  limitOrders       LimitOrder[]
  tpSlRules         TpSlRule[]
  scheduledStrategies ScheduledStrategy[]

  RefreshToken      RefreshToken[]
  refreshTokensV2   RefreshTokenV2[]     // NEW: relation to v2 refresh tokens

  // NEW: relations to new tables
  idempotencyRecords      IdempotencyRecord[]
  securityAuditLogs       SecurityAuditLog[]
  notificationPreferences NotificationPreference[]
  riskState               UserRiskState?

  // Payments
  subscriptionStatus String   @default("inactive") // e.g. active, canceled
  stripeCustomerId   String?  @unique              // Stripe customer ID
  stripeSubscriptionId String?                     // Stripe subscription ID
  plan               String   @default("free")     // free / basic / pro
  usage              Int      @default(0)          // current monthâ€™s usage in compute units
  usageResetAt       DateTime @default(now())      // when usage resets (monthly)
  credits            Decimal   @default(0.00)
  // accounts
  isDeleted          Boolean   @default(false)
  deletedAt          DateTime?
  lastPasswordChangeAt DateTime?
  accountStatus      String    @default("active")
  agreedToTermsAt     DateTime? // When user accepted Terms/Privacy
  // 2fa authentication
  is2FAEnabled      Boolean   @default(false)
  twoFactorSecret   String?
  require2faLogin   Boolean   @default(false) // â† NEW
  /// Indicates whether two-factor authentication should be required when arming a
  /// protected session. Login and arm requirements are controlled separately. A
  /// user may have two-factor disabled on login while still enforcing it when
  /// arming a wallet for trades. See `require2faLogin` for the login toggle.
  require2faArm    Boolean   @default(false)
  /// When a user opts to use the same pass-phrase for all current and future
  /// wallets this field stores the Argon2id hash of that pass-phrase. When
  /// creating or migrating wallets the backend will fall back to this hash
  /// whenever an individual wallet has no `passphraseHash` set. This allows
  /// per-wallet isolation even when a global pass-phrase exists.
  defaultPassphraseHash String?
  /// Optional short hint shown to the user for the global wallet pass-phrase.
  /// This is never used for authentication and is purely informational.
  passphraseHint        String?
  requireArmToTrade Boolean   @default(false)
  recoveryCodes    String[] 
  resetToken       String?
  resetExpires     DateTime?
  passwordResetToken    String? 
  passwordResetExpires  DateTime?
  // porfolio relationship
  portfolioTrackers PortfolioTracker[]
  netWorthSnapshots NetWorthSnapshot[]
  netWorthHistories NetWorthHistory[]
  // Web 3 Auth System 
  // type                 String   @default("web")
  phantomPublicKey     String? @unique
  vaultPublicKey       String?
  vaultPrivateKeyEnc   String?
  // trades  Trade[] @relation("UserTrades") 
  savedConfigs SavedConfigs[] 
  armDefaultMinutes  Int      @default(240)    // optional: default 4h
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Auto-Return to Cold Wallet (NEW) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  /// Default account-level toggle; per-session can override.
  autoReturnEnabledDefault      Boolean @default(false)
  /// Destination cold wallet pubkey (must be verified before use).
  autoReturnDestPubkey          String?
  /// Grace period in seconds before sweep after disarm/expiry.
  autoReturnGraceSeconds        Int     @default(10)
  /// Include SPL tokens in sweep (non-USDC first, then USDC).
  autoReturnSweepTokens         Boolean @default(true)
  /// Keep at least this many lamports (â‰ˆ0.01 SOL by default).
  autoReturnSolMinKeepLamports  BigInt  @default(10000000)
  /// Reserve lamports to cover fees during sweep.
  autoReturnFeeBufferLamports   BigInt  @default(10000)
  /// Mints to exclude from sweeping.
  autoReturnExcludeMints        String[]
  /// Mints considered USDC (swept after non-USDC).
  autoReturnUsdcMints           String[]
  /// When the destination pubkey was verified (null if not).
  autoReturnDestVerifiedAt      DateTime?
  armSessions ArmSession[]
  closedTrade   ClosedTrade[]   @relation("ClosedTrades")
  trades Trade[] @relation("UserTrades") 
}


model Wallet {
  id         Int      @id @default(autoincrement())
  label      String
  publicKey  String   @unique

  // ğŸ”» DEPRECATE this ASAP (stop writing plaintext to it)
  privateKey String ?   // make optional later, then drop after migration

  // NEW: envelope-encrypted blob (Argon2idâ†’AES-GCM object)
  encrypted  Json?    // stores {v,alg,kdf,{iv1,tag1,pkCipher},{iv2,tag2,dekCipher},aad}

  /// Argon2id hash of the pass-phrase protecting this wallet. If null the
  /// wallet inherits the user's `defaultPassphraseHash`. When non-null the
  /// wallet will only accept this specific pass-phrase on arm. This allows
  /// per-wallet isolation even when a global pass-phrase exists.
  passphraseHash String?

  /// Optional hint to help the user remember the pass-phrase for this wallet.
  /// If null the userâ€™s global `passphraseHint` may be displayed instead.
  passphraseHint String?

  isProtected Boolean @default(false) // true when using envelope+Arm
  encryptionVersion Int @default(1)   // future-proofing

  createdAt  DateTime @default(now())
  userId     String
  user       User     @relation("UserWallets", fields: [userId], references: [id])

  trades        Trade[]          @relation("WalletTrades")
  closed        ClosedTrade[]
  refreshTokens RefreshToken[]
  refreshTokensV2 RefreshTokenV2[]   // NEW: relation to v2 refresh tokens linked to this wallet
  tpSlRules     TpSlRule[]
  limitOrders   LimitOrder[]
  dcaOrders     DcaOrder[]
  scheduledStrategies ScheduledStrategy[]
  armSessions ArmSession[] 
  @@unique([userId, label])
}

model AuditLog {
  id        String   @id @default(uuid())
  userId    String
  event     String             // "ARM", "EXTEND", "DISARM", "SIGN"
  meta      Json?
  createdAt DateTime @default(now())

  @@index([userId, createdAt])
}

model Trade {
  id              Int       @id @default(autoincrement())
  mint            String
  tokenName       String?
  entryPrice      Float?
  entryPriceUSD   Float?
  inAmount        BigInt
  outAmount       BigInt
  closedOutAmount BigInt @default(0)
  exitPrice       Float?
  exitPriceUSD    Float?
  strategy        String
  walletLabel     String?
  txHash          String?   @unique
  unit            String
  slippage        Float?
  decimals        Int?
  usdValue        Float?
  type            String
  side            String
  botId           String
  triggerType     String?
  exitedAt        DateTime?
  timestamp       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt @default(now())
  inputMint       String?  
  outputMint      String?
   extras        Json?
  // ADD â†“â†“â†“
  userId          String
  createdAt       DateTime  @default(now())
  user     User   @relation("UserTrades", fields: [userId], references: [id], onDelete: Cascade)
  // ADD â†‘â†‘â†‘

  walletId        Int
  wallet   Wallet @relation("WalletTrades", fields: [walletId], references: [id], onDelete: Cascade)
  config          SavedConfigs[] @relation("TradeConfig")
  mevMode         String?
  priorityFee     Int?  
  briberyAmount   Int?   
  mevShared       Boolean  @default(false)
  source          String? 

  // paper-sim fields (unchanged)
  paperRunId            String?
  execModel             ExecModel?
  seed                  String?
  routeJson             Json?
  fillsJson             Json?
  latencyMs             Int?
  priorityFeeLamports   BigInt?
  cuEstimate            Int?
  feesTotalLamports     BigInt?
  simFillPrice          Decimal?
  slippageBps           Int?
  reasonCode            String?
  
}

model ClosedTrade {
  id              Int      @id @default(autoincrement())
  userId          String

  mint            String
  tokenName       String?
  entryPrice      Float?
  entryPriceUSD   Float?
  inAmount        BigInt
  outAmount       BigInt
  closedOutAmount BigInt
  exitPrice       Float?
  exitPriceUSD    Float?
  strategy        String
  walletLabel     String?
  txHash          String?  @unique
  unit            String
  slippage        Float?
  decimals        Int?
  usdValue        Float?
  type            String
  side            String
  botId           String
  triggerType     String?
  exitedAt        DateTime
  timestamp       DateTime @default(now())
  walletId Int
  wallet   Wallet @relation(fields: [walletId], references: [id])
  user     User   @relation("ClosedTrades", fields: [userId], references: [id], onDelete: Cascade)

}

model SavedConfigs {
  /// Primary key
  id             Int       @id @default(autoincrement())
  /// Owning user (optional)
  userId         String?
  isSaved        Boolean   @default(true)
  /// Name of the saved configuration
  name           String?
  /// Strategy this config applies to
  strategy       String?
  strategyName   String?

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Common / Base â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  amountToSpend        Float?
  snipeAmount          Float?
  slippage             Float?
  maxSlippage          Float?
  interval             Int?
  maxTrades            Int?
  tokenFeed            String?
  haltOnFailures       Boolean?
  autoSell             Json?
  priorityFeeLamports  Int?
  /// NOTE: keep the legacy boolean for compatibility; see mevModeStr below
  mevMode              Boolean?
  /// Preferred: string mode (e.g. "fast", "secure")
  mevModeStr           String?
  briberyAmount        Float?
  takeProfit           Float?
  stopLoss             Float?
  takeProfitPct        Float?
  stopLossPct          Float?
  tpPercent           Float?
  slPercent           Float?
  
  cooldown             Int?
  maxDailyVolume       Float?
  minTokenAgeMinutes   Int?
  maxTokenAgeMinutes   Int?
  minMarketCap         Float?
  maxMarketCap         Float?
  risk                 Float?
  volumeSpikeMultiplier Float?

  /// New common/base fields from builders
  monitoredTokens      Json?
  safetyEnabled        Boolean?
  safetyChecks         Json?
  maxOpenTrades        Int?
  /// Configurable liquidity floor (USD) â€“ default handled in builder/runtime
  minPoolUsd           Float?

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Sniper (and shared) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  entryThreshold       Float?
  volumeThreshold      Float?
  priceWindow          String?
  volumeWindow         String?

  /// Smart Exit (flat & nested)
  smartExitMode        String?  // "off" | "time" | "liquidity" | ...
  smartExit            Json?    // { time: { maxHoldSec, minPnLBeforeTimeExitPct }, ... }

  /// Post-buy watcher (flat fallbacks + nested)
  postBuyWatch         Json?    // { intervalSec, authorityFlipExit, lpOutflowExitPct, rugDelayBlocks }
  intervalSec          Int?
  authorityFlipExit    Boolean?
  lpOutflowExitPct     Float?
  rugDelayBlocks       Int?

  /// Flat time-exit fallbacks used by sanitizer/validator
  timeMaxHoldSec                     Int?
  timeMinPnLBeforeTimeExitPct        Float?

  delayBeforeBuyMs     Int?

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Dip Buyer â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  dipThreshold         Float?
  recoveryWindow       String?

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Breakout â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  breakoutThreshold    Float?

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Trend Follower â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  priceChangeThreshold Float?
  trendWindow          String?
  emaPeriods           Json?
  trailingPct          Float?
  sarEnabled           Boolean?
  pyramidEnabled       Boolean?
  riskPerAdd           Float?
  maxRisk              Float?
  maxHoldSeconds       Int?
  useSignals           Boolean?

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Delayed Sniper â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // (you already had delayBeforeBuyMs above)
  breakoutPct          Float?
  pullbackPct          Float?
  ignoreBlocks         Int?

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Chad Mode / Multi-target â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  outputMint           String?
  outputMints          Json?
  targetTokens         Json?
  minVolumeRequired    Float?
  slippageMaxPct       Float?
  feeEscalationLamports Int?
  panicDumpPct         Float?

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Rebalancer â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  walletLabels         Json?
  maxRebalances        Int?
  targetAllocations    Json?
  targetWeights        Json?
  rebalanceThreshold   Float?
  rebalanceInterval    Int?
  autoWallet           Boolean?

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Rotation Bot â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  wallets              Json?
  sectors              Json?
  tokens               Json?
  rotationInterval     Int?
  priceChangeWindow    String?
  minMomentum          Float?
  positionSize         Float?
  maxRotations         Int?

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Paper Trader â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  dryRun               Boolean?
  maxSpendPerToken     Float?
  slippageBpsCap       Int?
  latency              Json?
  failureRates         Json?
  partials             Json?
  enableShadowMode     Boolean?
  execModel            String?
  seed                 String?


  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Turbo Sniper specific (already present, ensure full coverage)
  ghostMode            Boolean?
  coverWalletId        String?
  multiBuy             Boolean?
  multiBuyCount        Int?
  prewarmAccounts      Boolean?
  multiRoute           Boolean?
  autoRug              Boolean?
  useJitoBundle        Boolean?
  jitoTipLamports      Int?
  jitoRelayUrl         String?
  autoPriorityFee      Boolean?
  rpcEndpoints         Json?
  rpcMaxErrors         Int?
  killSwitch           Boolean?
  killThreshold        Int?
  poolDetection        Boolean?
  allowedDexes         Json?
  excludedDexes        Json?
  splitTrade           Boolean?
  tpLadder             Json?
  trailingStopPct      Float?
  turboMode            Boolean?
  autoRiskManage       Boolean?
  privateRpcUrl        String?
  /// optional future wiring (some builds refer to liqGate/ui objects)
  liqGate              Json?
  ui                   Json?
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Misc/Infra â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  extras               Json?
  savedAt              DateTime  @default(now())
  createdAt            DateTime  @default(now())

  trades               Trade[]   @relation("TradeConfig")
  User                 User[]
}

model StrategyRunStatus {
  id          String   @id @default(uuid())
  botId       String   @unique
  userId      String
  mode        String
  configId    Int?     // FK to StrategyConfig
  pid         Int?
  startedAt   DateTime @default(now())
  pausedAt    DateTime?
  stoppedAt   DateTime?
  isPaused    Boolean  @default(false)
  lastTickAt  DateTime?
  status      String   @default("running")  // running / paused / stopped / completed
  config      Json?
  @@index([userId])
}

model PortfolioTracker {
  id            Int      @id @default(autoincrement())
  startTs       BigInt
  lastMonthlyTs BigInt
  createdAt     DateTime @default(now())
  userId String
  user   User @relation(fields: [userId], references: [id])
}

model NetWorthSnapshot {
  id            Int      @id @default(autoincrement())
  ts            BigInt
  netWorth      Float
  sol           Float
  usdc          Float
  openPositions Int
  createdAt     DateTime @default(now())
  userId String
  user   User @relation(fields: [userId], references: [id])
}

model NetWorthHistory {
  id        Int      @id @default(autoincrement())
  ts        BigInt
  date      String
  minute    String
  value     Float
  createdAt DateTime @default(now())
  userId String
  user   User @relation(fields: [userId], references: [id])
  @@unique([userId, date], name: "userId_date")
}

model LimitOrder {
  id          String    @id @default(uuid())
  type        String    @default("limit")
  token       String
  mint        String
  price       Float
  targetPrice Float
  side        String
  amount      Float
  force       Boolean   @default(false)
  walletLabel String
  walletId    Int
  wallet      Wallet    @relation(fields: [walletId], references: [id])
  userId      String
  user        User      @relation(fields: [userId], references: [id])
  status      String    @default("open")
  tx          String?   // âœ… NEW transaction hash column
  createdAt   DateTime  @default(now())
  executedAt  DateTime? // execution timestamp (if executed)
  @@index([mint])
  @@index([userId])
  @@index([walletLabel])
  @@index([status])
  @@index([walletId])
}

model DcaOrder {
  id            String    @id @default(uuid())
  type          String    @default("dca")
  side          String
  mint          String
  tokenMint     String
  amount        Float
  unit          String
  firstBuyNow   Boolean  @default(false) 
  numBuys       Int
  totalBuys     Int
  frequency     Float
  freqHours     Float
  stopAbove     Float?
  stopBelow     Float?
  walletLabel   String?
  walletId      Int      // âœ… NEW FK
  wallet        Wallet   @relation(fields: [walletId], references: [id])
  userId        String
  user          User     @relation(fields: [userId], references: [id])
  force         Boolean   @default(false)
  amountPerBuy  Float
  completedBuys Int       @default(0)
  executedCount Int       @default(0)
  missedCount   Int       @default(0)
  needsFunding  Boolean   @default(false)
  status        String    @default("active")
  tx            String?
  createdAt     DateTime  @default(now())
  lastBuyAt     DateTime?
  filledAt      DateTime?
  @@index([mint])
  @@index([userId])
  @@index([walletLabel])
  @@index([status])
}

model TpSlRule {
  id          String   @id @default(uuid())
  mint        String
  walletId    Int
  userId      String
  strategy    String
  tp          Float?
  sl          Float?
  tpPercent   Float?
  slPercent   Float?
  sellPct     Int?   
  entryPrice  Float?
  enabled     Boolean  @default(true)
  status      String   @default("active")
  force       Boolean  @default(false)
  failCount   Int      @default(0)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt 
  user   User   @relation(fields: [userId], references: [id])
  wallet Wallet @relation(fields: [walletId], references: [id])
  @@index([mint])
  @@index([userId])
  @@index([strategy])
  // @@unique([userId, walletId, mint, strategy], name: "userId_walletId_mint_strategy")
}

model TelegramPreference {
  id        String   @id @default(uuid())
  userId    String
  chatId String? @unique 
  enabled   Boolean  @default(true)
  types     String[]
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  user User @relation(fields: [userId], references: [id])
  @@unique([userId])
  @@index([chatId])
}

model UserPreference {
  id                 String   @id @default(uuid())
  userId             String   @unique
  context            String   @default("default")
  degenMode          Boolean  @default(false)
  confirmBeforeTrade Boolean  @default(true)
  alertsEnabled      Boolean  @default(true)
  slippage           Float    @default(1.0)
  defaultMaxSlippage        Float    @default(2.0)    
  mevMode     String   @default("fast")     
  defaultPriorityFee        Int      @default(0)       
  briberyAmount      Float      @default(0)         
  autoBuyEnabled     Boolean  @default(false)
  autoBuyAmount      Float    @default(0.0)
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt
  user User @relation(fields: [userId], references: [id])
  @@unique([userId, context])
}

model ScheduledStrategy {
  id          String   @id @default(uuid())
  sortId      Int      @unique @default(autoincrement())
  name        String? 
  mode        String
  config      Json
  launchISO   DateTime
  buyMode     String   @default("interval")
  targetToken String?
  limit       Json?
  /* â”€â”€â”€ FKâ€™s â”€â”€â”€ */
  walletId    Int
  wallet      Wallet   @relation(fields: [walletId], references: [id])
  userId      String
  user        User     @relation(fields: [userId], references: [id])
  status      String   @default("pending")
  startedAt   DateTime?                   
  finishedAt  DateTime?                   
  /* â”€â”€â”€ meta â”€â”€â”€ */
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  /* â”€â”€â”€ indexes â”€â”€â”€ */
  @@index([launchISO])
  @@index([walletId])
  @@index([userId])
}

model RefreshToken {
  id        String   @id @default(uuid())
  token     String
  userId    String
  createdAt DateTime @default(now())
  user     User    @relation(fields: [userId], references: [id])
  Wallet   Wallet? @relation(fields: [walletId], references: [id])
  walletId Int?
  @@index([token])
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ArmSession (NEW) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
/// Stores per-session overrides for auto-return at arm time.
model ArmSession {
  id                   Int      @id @default(autoincrement())
  userId               String
  walletId             Int
  autoReturnEnabled    Boolean  @default(false)
  autoReturnDestPubkey String?
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt
  user   User   @relation(fields: [userId], references: [id])
  wallet Wallet @relation(fields: [walletId], references: [id])
  @@index([userId])
  @@index([walletId])
}


// Added in paper-sim-upgrade
// Execution model for paper simulations.  When execModel is not set
// the simulator behaves like the legacy ideal fill.  Additional
// models introduce depthâ€‘aware pricing and Jito fallback logic.
enum ExecModel {
  ideal
  amm_depth
  jito_fallback
}



/// Stores results for idempotent API calls.  Each record is keyed by user and a
/// unique idempotency key.  On repeat calls within the TTL window the stored
/// response body and status are returned immediately.  Expired records should
/// be purged by a scheduled job.
model IdempotencyRecord {
  id           Int       @id @default(autoincrement())
  userId       String
  // ADD â†“â†“â†“
  user         User      @relation(fields: [userId], references: [id])
  // ADD â†‘â†‘â†‘
  key          String
  status       Int
  resultHash   String
  payload      Bytes
  createdAt    DateTime  @default(now())
  expiresAt    DateTime
  @@unique([userId, key])
}

/// Refresh tokens with rotation and reuse detection.  This table stores each
/// issued refresh token along with a family identifier.  When a refresh token
/// is used the old token is revoked and replaced with a new one.  Reuse of a
/// revoked token will revoke the entire family.
model RefreshTokenV2 {
  id           Int      @id @default(autoincrement())
  userId       String
  jti          String   // JWT ID
  familyId     String
  revokedAt    DateTime?
  createdAt    DateTime @default(now())
  expiresAt    DateTime
  userAgent    String?
  ip           String?
  walletId     Int?
  user         User     @relation(fields: [userId], references: [id])
  wallet       Wallet?  @relation(fields: [walletId], references: [id])
  @@unique([userId, jti])
}

/// Append-only security log with tamper-evident hash chain.  Each row stores
/// the previous hash and the current hash computed via HMAC over the metadata.
/// Consumers should never update or delete rows in this table.
model SecurityAuditLog {
  id         Int      @id @default(autoincrement())
  ts         DateTime @default(now())
  userId     String
  user       User     @relation(fields: [userId], references: [id]) // â† ADD THIS
  type       String
  metaJson   Json?
  prevHash   String?
  hash       String
  @@index([userId, ts])
}

/// Per-user notification channel preferences.  Each user can enable or disable
/// specific channels (email, telegram, slack, webhook) per event type.  The
/// metaJson field stores channel specific metadata such as webhook URLs or
/// Slack tokens.
model NotificationPreference {
  id         Int      @id @default(autoincrement())
  userId     String
  event      String    // event name, e.g. "TRADE_EXECUTED"
  channel    String    // "email", "telegram", "slack", "webhook"
  enabled    Boolean   @default(true)
  metaJson   Json?
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @default(now()) @updatedAt
  user       User      @relation(fields: [userId], references: [id])
  @@unique([userId, event, channel])
}

/// Token safety verdicts and allow/deny lists.  The `status` field is one of
/// "allow", "warn" or "deny".  The `reason` provides a human-friendly
/// explanation and the `metaJson` can store additional context.
model TokenSafetyList {
  mint       String   @id
  status     String
  reason     String?
  metaJson   Json?
  updatedAt  DateTime  @default(now()) @updatedAt
}

/// Per-user risk state used by the crossâ€‘strategy risk engine.  Tracks daily
/// losses and current exposures across tokens and sectors.  A kill switch can
/// be engaged when any limit is breached.  Daily totals are reset by a
/// scheduled job at midnight UTC.
model UserRiskState {
  id             Int       @id @default(autoincrement())
  userId         String    @unique
  dailyLossUsd   Float     @default(0)
  exposureUsd    Float     @default(0)
  exposuresJson  Json      @default("{}") // JSON map of mint/sector to exposure
  killSwitch     Boolean   @default(false)
  killEngagedAt  DateTime?
  updatedAt      DateTime  @default(now()) @updatedAt
  user           User      @relation(fields: [userId], references: [id])
}



model StrategyCrash {
  id        String   @id @default(uuid())
  botId     String
  userId    String?
  mode      String?
  event     String   // uncaughtException | unhandledRejection | exit | signal:SIGTERM | spawnError | ...
  message   String?
  stack     String?
  createdAt DateTime @default(now())

  @@index([botId, createdAt])
  @@index([userId, createdAt])
}