generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id               String     @id @default(uuid()) // User's unique ID
  activeWalletId   Int?                                // FK to one of the user's wallets
  type             String     @default("telegram")
  userId           String     @unique                // Renamed externalId to userId
  username         String?    @unique                // Added username field
  hashedPassword   String?
  email            String?    @unique
  createdAt        DateTime   @default(now())
  wallets          Wallet[]   @relation("UserWallets") // Relation to multiple wallets
  telegramPreferences TelegramPreference[]
  userPreferences   UserPreference[]
  dcaOrders         DcaOrder[]
  limitOrders       LimitOrder[]
  tpSlRules         TpSlRule[]
  scheduledStrategies ScheduledStrategy[]
  RefreshToken      RefreshToken[]
  // Payments
  subscriptionStatus String   @default("inactive") // e.g. active, canceled
  stripeCustomerId   String?  @unique              // Stripe customer ID
  stripeSubscriptionId String?                     // Stripe subscription ID
  plan               String   @default("free")     // free / basic / pro
  usage              Int      @default(0)          // current month‚Äôs usage in compute units
  usageResetAt       DateTime @default(now())      // when usage resets (monthly)
  credits            Decimal   @default(0.00)
  // accounts
  isDeleted          Boolean   @default(false)
  deletedAt          DateTime?
  lastPasswordChangeAt DateTime?
  accountStatus      String    @default("active")
  agreedToTermsAt     DateTime? // When user accepted Terms/Privacy
  // 2fa authentication
  is2FAEnabled      Boolean   @default(false)
  twoFactorSecret   String?
  require2faLogin   Boolean   @default(false) // ‚Üê NEW
  /// Indicates whether two-factor authentication should be required when arming a
  /// protected session. Login and arm requirements are controlled separately. A
  /// user may have two-factor disabled on login while still enforcing it when
  /// arming a wallet for trades. See `require2faLogin` for the login toggle.
  require2faArm    Boolean   @default(false)

  /// When a user opts to use the same pass-phrase for all current and future
  /// wallets this field stores the Argon2id hash of that pass-phrase. When
  /// creating or migrating wallets the backend will fall back to this hash
  /// whenever an individual wallet has no `passphraseHash` set. If null no
  /// global pass-phrase is defined.
  defaultPassphraseHash String?

  /// Optional short hint shown to the user for the global wallet pass-phrase.
  /// This is never used for authentication and is purely informational.
  passphraseHint        String?
  requireArmToTrade Boolean   @default(false)
  recoveryCodes    String[] 
  resetToken       String?
  resetExpires     DateTime?
  passwordResetToken    String? 
  passwordResetExpires  DateTime?
  // porfolio relationship
  portfolioTrackers PortfolioTracker[]
  netWorthSnapshots NetWorthSnapshot[]
  netWorthHistories NetWorthHistory[]
  // Web 3 Auth System 
  // type                 String   @default("web")
  phantomPublicKey     String? @unique
  vaultPublicKey       String?
  vaultPrivateKeyEnc   String?
  // trades  Trade[] @relation("UserTrades") 
  savedConfigs SavedConfigs[] 
  armDefaultMinutes  Int      @default(240)    // optional: default 4h

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Auto-Return to Cold Wallet (NEW) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  /// Default account-level toggle; per-session can override.
  autoReturnEnabledDefault      Boolean @default(false)
  /// Destination cold wallet pubkey (must be verified before use).
  autoReturnDestPubkey          String?
  /// Grace period in seconds before sweep after disarm/expiry.
  autoReturnGraceSeconds        Int     @default(10)
  /// Include SPL tokens in sweep (non-USDC first, then USDC).
  autoReturnSweepTokens         Boolean @default(true)
  /// Keep at least this many lamports (‚âà0.01 SOL by default).
  autoReturnSolMinKeepLamports  BigInt  @default(10000000)
  /// Reserve lamports to cover fees during sweep.
  autoReturnFeeBufferLamports   BigInt  @default(10000)
  /// Mints to exclude from sweeping.
  autoReturnExcludeMints        String[]
  /// Mints considered USDC (swept after non-USDC).
  autoReturnUsdcMints           String[]
  /// When the destination pubkey was verified (null if not).
  autoReturnDestVerifiedAt      DateTime?
}

model Wallet {
  id         Int      @id @default(autoincrement())
  label      String
  publicKey  String   @unique

  // üîª DEPRECATE this ASAP (stop writing plaintext to it)
  privateKey String ?   // make optional later, then drop after migration

  // üîê NEW: envelope-encrypted blob (Argon2id‚ÜíAES-GCM object)
  encrypted  Json?    // stores {v,alg,kdf,{iv1,tag1,pkCipher},{iv2,tag2,dekCipher},aad}

  /// Argon2id hash of the pass-phrase protecting this wallet. If null the
  /// wallet inherits the user's `defaultPassphraseHash`. When non-null the
  /// wallet will only accept this specific pass-phrase on arm. This allows
  /// per-wallet isolation even when a global pass-phrase exists.
  passphraseHash String?

  /// Optional hint to help the user remember the pass-phrase for this wallet.
  /// If null the user‚Äôs global `passphraseHint` may be displayed instead.
  passphraseHint String?

  isProtected Boolean @default(false) // true when using envelope+Arm
  encryptionVersion Int @default(1)   // future-proofing

  createdAt  DateTime @default(now())
  userId     String
  user       User     @relation("UserWallets", fields: [userId], references: [id])

  trades        Trade[]          @relation("WalletTrades")
  closed        ClosedTrade[]
  refreshTokens RefreshToken[]
  tpSlRules     TpSlRule[]
  limitOrders   LimitOrder[]
  dcaOrders     DcaOrder[]
  scheduledStrategies ScheduledStrategy[]

  @@unique([userId, label])
}

model AuditLog {
  id        String   @id @default(uuid())
  userId    String
  event     String             // "ARM", "EXTEND", "DISARM", "SIGN"
  meta      Json?
  createdAt DateTime @default(now())

  @@index([userId, createdAt])
}

model Trade {
  id              Int       @id @default(autoincrement())
  mint            String
  tokenName       String?
  entryPrice      Float?
  entryPriceUSD   Float?
  inAmount        BigInt
  outAmount       BigInt
  closedOutAmount BigInt
  exitPrice       Float?
  exitPriceUSD    Float?
  strategy        String
  walletLabel     String?
  txHash          String?   @unique
  unit            String
  slippage        Float?
  decimals        Int?
  usdValue        Float?
  type            String
  side            String
  botId           String
  triggerType     String?
  exitedAt        DateTime?
  timestamp       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt @default(now())
  inputMint       String?  
  outputMint      String? 
  // userId          String?
  // user   User? @relation("UserTrades", fields: [userId], references: [id])
  walletId Int
  wallet   Wallet           @relation("WalletTrades", fields: [walletId], references: [id])
  config   SavedConfigs[] @relation("TradeConfig")
  mevMode        String?
  priorityFee   Int?  
  briberyAmount  Int?   
  mevShared     Boolean  @default(false)
  source          String? 
}

model ClosedTrade {
  id              Int      @id @default(autoincrement())
  mint            String
  tokenName       String?
  entryPrice      Float?
  entryPriceUSD   Float?
  inAmount        BigInt
  outAmount       BigInt
  closedOutAmount BigInt
  exitPrice       Float?
  exitPriceUSD    Float?
  strategy        String
  walletLabel     String?
  txHash          String?  @unique
  unit            String
  slippage        Float?
  decimals        Int?
  usdValue        Float?
  type            String
  side            String
  botId           String
  triggerType     String?
  exitedAt        DateTime
  timestamp       DateTime @default(now())
  walletId Int
  wallet   Wallet @relation(fields: [walletId], references: [id])
}

model SavedConfigs {
  id           Int      @id @default(autoincrement())
  strategyName String
  /* --- preset metadata --- */
  isSaved      Boolean  @default(false)
  savedAt      DateTime?
  name         String?
  colorTag     String?
  /* Core shared */
  amountToSpend       Float?
  snipeAmount         Float?
  slippage            Float?
  interval            Int?
  maxTrades           Int?
  tokenFeed           String?
  inputMint           String?
  sectors             Json?
  trade               Trade[]  @relation("TradeConfig")
  dryRun              Boolean  @default(true)
  /* Thresholds & windows */
  entryThreshold        Float?
  volumeThreshold       Float?
  priceWindow           Int?
  volumeWindow          Int?
  minTokenAgeMinutes    Int?
  maxTokenAgeMinutes    Int?
  dipThreshold          Float?
  recoveryWindow        Int?
  breakoutThreshold     Float?
  trendWindow           Int?
  delayMs               Int?
  minVolumeRequired     Float?
  slippageMaxPct        Float?
  feeEscalationLamports Float?
  panicDumpPct          Float?
  priceChangeWindow     Int?
  rotationInterval      Int?
  minMomentum           Float?
  positionSize          Float?
  cooldown              Int?
  maxDailyVolume        Float?
  maxRotations          Int?
  maxRebalances         Int?
  rebalanceThreshold    Float?
  rebalanceInterval     Int?
  targetAllocations     String?
  maxTradesPerCycle     Int?
  maxDailyTrades        Int?
  minSolBalance         Float?
  volumeSpikeMultiplier Float?
  minLiquidity          Float?
  minMarketCap          Float?
  maxMarketCap          Float?
  skipSafety            Boolean?
  /* TP / SL & auto-sell */
  takeProfit         Float?
  tpPercent          Float?
  stopLoss           Float?
  slPercent          Float?
  autoSell           Json?
  /* MEV / Fees snapshot */
  mevMode            String?
  priorityFee        Int?
  priorityFeeLamports Int?
  briberyAmount      Int?
  maxSlippage        Float?
  defaultMaxSlippage Float?
  /* Scheduler extras */
  // buyMode            String?
  limitConfigs       Json?
  /* Stealth / multi-target */
  tokenMint          String?
  /* ARRAY defaults are allowed on PostgreSQL ‚Äì Prisma ‚â• 6.0 */
  monitoredTokens   String[] @default([])
  tokens            String[] @default([])
  outputMints       String[] @default([])
  limitPrices       Float[]  @default([])
  /* Catch-all for future flags */
  extras             Json?
  userId   String
  user     User     @relation(fields: [userId], references: [id])
}

model StrategyRunStatus {
  id          String   @id @default(uuid())
  botId       String   @unique
  userId      String
  mode        String
  configId    Int?     // FK to StrategyConfig
  pid         Int?
  startedAt   DateTime @default(now())
  pausedAt    DateTime?
  stoppedAt   DateTime?
  isPaused    Boolean  @default(false)
  lastTickAt  DateTime?
  status      String   @default("running")  // running / paused / stopped / completed
  config      Json?
  @@index([userId])
}

model PortfolioTracker {
  id            Int      @id @default(autoincrement())
  startTs       BigInt
  lastMonthlyTs BigInt
  createdAt     DateTime @default(now())
  userId String
  user   User @relation(fields: [userId], references: [id])
}

model NetWorthSnapshot {
  id            Int      @id @default(autoincrement())
  ts            BigInt
  netWorth      Float
  sol           Float
  usdc          Float
  openPositions Int
  createdAt     DateTime @default(now())
  userId String
  user   User @relation(fields: [userId], references: [id])
}

model NetWorthHistory {
  id        Int      @id @default(autoincrement())
  ts        BigInt
  date      String
  minute    String
  value     Float
  createdAt DateTime @default(now())
  userId String
  user   User @relation(fields: [userId], references: [id])
  @@unique([userId, date], name: "userId_date")
}

model LimitOrder {
  id          String    @id @default(uuid())
  type        String    @default("limit")
  token       String
  mint        String
  price       Float
  targetPrice Float
  side        String
  amount      Float
  force       Boolean   @default(false)
  walletLabel String
  walletId    Int
  wallet      Wallet    @relation(fields: [walletId], references: [id])
  userId      String
  user        User      @relation(fields: [userId], references: [id])
  status      String    @default("open")
  tx          String?   // ‚úÖ NEW transaction hash column
  createdAt   DateTime  @default(now())
  executedAt  DateTime? // execution timestamp (if executed)
  @@index([mint])
  @@index([userId])
  @@index([walletLabel])
  @@index([status])
  @@index([walletId])
}

model DcaOrder {
  id            String    @id @default(uuid())
  type          String    @default("dca")
  side          String
  mint          String
  tokenMint     String
  amount        Float
  unit          String
  numBuys       Int
  totalBuys     Int
  frequency     Float
  freqHours     Float
  stopAbove     Float?
  stopBelow     Float?
  walletLabel   String?
  walletId      Int      // ‚úÖ NEW FK
  wallet        Wallet   @relation(fields: [walletId], references: [id])
  userId        String
  user          User     @relation(fields: [userId], references: [id])
  force         Boolean   @default(false)
  amountPerBuy  Float
  completedBuys Int       @default(0)
  executedCount Int       @default(0)
  missedCount   Int       @default(0)
  needsFunding  Boolean   @default(false)
  status        String    @default("active")
  tx            String?
  createdAt     DateTime  @default(now())
  lastBuyAt     DateTime?
  filledAt      DateTime?
  @@index([mint])
  @@index([userId])
  @@index([walletLabel])
  @@index([status])
}

model TpSlRule {
  id          String   @id @default(uuid())
  mint        String
  walletId    Int
  userId      String
  strategy    String
  tp          Float?
  sl          Float?
  tpPercent   Float?
  slPercent   Float?
  sellPct     Int?   
  entryPrice  Float?
  enabled     Boolean  @default(true)
  status      String   @default("active")
  force       Boolean  @default(false)
  failCount   Int      @default(0)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt 
  user   User   @relation(fields: [userId], references: [id])
  wallet Wallet @relation(fields: [walletId], references: [id])
  @@index([mint])
  @@index([userId])
  @@index([strategy])
  // @@unique([userId, walletId, mint, strategy], name: "userId_walletId_mint_strategy")
}

model TelegramPreference {
  id        String   @id @default(uuid())
  userId    String
  chatId String? @unique 
  enabled   Boolean  @default(true)
  types     String[]
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  user User @relation(fields: [userId], references: [id])
  @@unique([userId])
  @@index([chatId])
}

model UserPreference {
  id                 String   @id @default(uuid())
  userId             String   @unique
  context            String   @default("default")
  degenMode          Boolean  @default(false)
  confirmBeforeTrade Boolean  @default(true)
  alertsEnabled      Boolean  @default(true)
  slippage           Float    @default(1.0)
  defaultMaxSlippage        Float    @default(2.0)    
  mevMode     String   @default("fast")     
  defaultPriorityFee        Int      @default(0)       
  briberyAmount      Int      @default(0)         
  autoBuyEnabled     Boolean  @default(false)
  autoBuyAmount      Float    @default(0.0)
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt
  user User @relation(fields: [userId], references: [id])
  @@unique([userId, context])
}

model ScheduledStrategy {
  id          String   @id @default(uuid())
  sortId      Int      @unique @default(autoincrement())
  name        String? 
  mode        String
  config      Json
  launchISO   DateTime
  buyMode     String   @default("interval")
  targetToken String?
  limit       Json?
  /* ‚îÄ‚îÄ‚îÄ FK‚Äôs ‚îÄ‚îÄ‚îÄ */
  walletId    Int
  wallet      Wallet   @relation(fields: [walletId], references: [id])
  userId      String
  user        User     @relation(fields: [userId], references: [id])
  status      String   @default("pending")
  startedAt   DateTime?                   
  finishedAt  DateTime?                   
  /* ‚îÄ‚îÄ‚îÄ meta ‚îÄ‚îÄ‚îÄ */
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  /* ‚îÄ‚îÄ‚îÄ indexes ‚îÄ‚îÄ‚îÄ */
  @@index([launchISO])
  @@index([walletId])
  @@index([userId])
}

model RefreshToken {
  id        String   @id @default(uuid())
  token     String
  userId    String
  createdAt DateTime @default(now())
  user     User    @relation(fields: [userId], references: [id])
  Wallet   Wallet? @relation(fields: [walletId], references: [id])
  walletId Int?
  @@index([token])
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ ArmSession (NEW) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
/// Stores per-session overrides for auto-return at arm time.
model ArmSession {
  id                   Int      @id @default(autoincrement())
  userId               String
  walletId             Int
  autoReturnEnabled    Boolean  @default(false)
  autoReturnDestPubkey String?
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt
  user   User   @relation(fields: [userId], references: [id])
  wallet Wallet @relation(fields: [walletId], references: [id])
  @@index([userId])
  @@index([walletId])
}
