generator client {
  provider = "prisma-client-js"
}

/// Stores results for idempotent API calls.  Each record is keyed by user and a
/// unique idempotency key.  On repeat calls within the TTL window the stored
/// response body and status are returned immediately.  Expired records should
/// be purged by a scheduled job.
model IdempotencyRecord {
  id           Int       @id @default(autoincrement())
  userId       String
  key          String
  status       Int
  resultHash   String
  payload      Bytes
  createdAt    DateTime  @default(now())
  expiresAt    DateTime
  @@unique([userId, key])
}

/// Refresh tokens with rotation and reuse detection.  This table stores each
/// issued refresh token along with a family identifier.  When a refresh token
/// is used the old token is revoked and replaced with a new one.  Reuse of a
/// revoked token will revoke the entire family.
model RefreshTokenV2 {
  id           Int      @id @default(autoincrement())
  userId       String
  jti          String   // JWT ID
  familyId     String
  revokedAt    DateTime?
  createdAt    DateTime @default(now())
  expiresAt    DateTime
  userAgent    String?
  ip           String?
  walletId     Int?
  user         User     @relation(fields: [userId], references: [id])
  wallet       Wallet?  @relation(fields: [walletId], references: [id])
  @@unique([userId, jti])
}

/// Append-only security log with tamper-evident hash chain.  Each row stores
/// the previous hash and the current hash computed via HMAC over the metadata.
/// Consumers should never update or delete rows in this table.
model SecurityAuditLog {
  id         Int      @id @default(autoincrement())
  ts         DateTime @default(now())
  userId     String
  type       String
  metaJson   Json?
  prevHash   String?
  hash       String
  @@index([userId, ts])
}

/// Per-user notification channel preferences.  Each user can enable or disable
/// specific channels (email, telegram, slack, webhook) per event type.  The
/// metaJson field stores channel specific metadata such as webhook URLs or
/// Slack tokens.
model NotificationPreference {
  id         Int      @id @default(autoincrement())
  userId     String
  event      String    // event name, e.g. "TRADE_EXECUTED"
  channel    String    // "email", "telegram", "slack", "webhook"
  enabled    Boolean   @default(true)
  metaJson   Json?
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @default(now()) @updatedAt
  user       User      @relation(fields: [userId], references: [id])
  @@unique([userId, event, channel])
}

/// Token safety verdicts and allow/deny lists.  The `status` field is one of
/// "allow", "warn" or "deny".  The `reason` provides a human-friendly
/// explanation and the `metaJson` can store additional context.
model TokenSafetyList {
  mint       String   @id
  status     String
  reason     String?
  metaJson   Json?
  updatedAt  DateTime  @default(now()) @updatedAt
}

/// Per-user risk state used by the cross‚Äëstrategy risk engine.  Tracks daily
/// losses and current exposures across tokens and sectors.  A kill switch can
/// be engaged when any limit is breached.  Daily totals are reset by a
/// scheduled job at midnight UTC.
model UserRiskState {
  id             Int       @id @default(autoincrement())
  userId         String    @unique
  dailyLossUsd   Float     @default(0)
  exposureUsd    Float     @default(0)
  exposuresJson  Json      @default("{}") // JSON map of mint/sector to exposure
  killSwitch     Boolean   @default(false)
  killEngagedAt  DateTime?
  updatedAt      DateTime  @default(now()) @updatedAt
  user           User      @relation(fields: [userId], references: [id])
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id               String     @id @default(uuid()) // User's unique ID
  activeWalletId   Int?                                // FK to one of the user's wallets
  type             String     @default("telegram")
  userId           String     @unique                // Renamed externalId to userId
  username         String?    @unique                // Added username field
  hashedPassword   String?
  email            String?    @unique
  createdAt        DateTime   @default(now())
  wallets          Wallet[]   @relation("UserWallets") // Relation to multiple wallets
  telegramPreferences TelegramPreference[]
  userPreferences   UserPreference[]
  dcaOrders         DcaOrder[]
  limitOrders       LimitOrder[]
  tpSlRules         TpSlRule[]
  scheduledStrategies ScheduledStrategy[]
  RefreshToken      RefreshToken[]
  // Payments
  subscriptionStatus String   @default("inactive") // e.g. active, canceled
  stripeCustomerId   String?  @unique              // Stripe customer ID
  stripeSubscriptionId String?                     // Stripe subscription ID
  plan               String   @default("free")     // free / basic / pro
  usage              Int      @default(0)          // current month‚Äôs usage in compute units
  usageResetAt       DateTime @default(now())      // when usage resets (monthly)
  credits            Decimal   @default(0.00)
  // accounts
  isDeleted          Boolean   @default(false)
  deletedAt          DateTime?
  lastPasswordChangeAt DateTime?
  accountStatus      String    @default("active")
  agreedToTermsAt     DateTime? // When user accepted Terms/Privacy
  // 2fa authentication
  is2FAEnabled      Boolean   @default(false)
  twoFactorSecret   String?
  require2faLogin   Boolean   @default(false) // ‚Üê NEW
  /// Indicates whether two-factor authentication should be required when arming a
  /// protected session. Login and arm requirements are controlled separately. A
  /// user may have two-factor disabled on login while still enforcing it when
  /// arming a wallet for trades. See `require2faLogin` for the login toggle.
  require2faArm    Boolean   @default(false)
  /// When a user opts to use the same pass-phrase for all current and future
  /// wallets this field stores the Argon2id hash of that pass-phrase. When
  /// creating or migrating wallets the backend will fall back to this hash
  /// whenever an individual wallet has no `passphraseHash` set. If null no
  /// global pass-phrase is defined.
  defaultPassphraseHash String?
  /// Optional short hint shown to the user for the global wallet pass-phrase.
  /// This is never used for authentication and is purely informational.
  passphraseHint        String?
  requireArmToTrade Boolean   @default(false)
  recoveryCodes    String[] 
  resetToken       String?
  resetExpires     DateTime?
  passwordResetToken    String? 
  passwordResetExpires  DateTime?
  // porfolio relationship
  portfolioTrackers PortfolioTracker[]
  netWorthSnapshots NetWorthSnapshot[]
  netWorthHistories NetWorthHistory[]
  // Web 3 Auth System 
  // type                 String   @default("web")
  phantomPublicKey     String? @unique
  vaultPublicKey       String?
  vaultPrivateKeyEnc   String?
  // trades  Trade[] @relation("UserTrades") 
  savedConfigs SavedConfigs[] 
  armDefaultMinutes  Int      @default(240)    // optional: default 4h
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Auto-Return to Cold Wallet (NEW) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  /// Default account-level toggle; per-session can override.
  autoReturnEnabledDefault      Boolean @default(false)
  /// Destination cold wallet pubkey (must be verified before use).
  autoReturnDestPubkey          String?
  /// Grace period in seconds before sweep after disarm/expiry.
  autoReturnGraceSeconds        Int     @default(10)
  /// Include SPL tokens in sweep (non-USDC first, then USDC).
  autoReturnSweepTokens         Boolean @default(true)
  /// Keep at least this many lamports (‚âà0.01 SOL by default).
  autoReturnSolMinKeepLamports  BigInt  @default(10000000)
  /// Reserve lamports to cover fees during sweep.
  autoReturnFeeBufferLamports   BigInt  @default(10000)
  /// Mints to exclude from sweeping.
  autoReturnExcludeMints        String[]
  /// Mints considered USDC (swept after non-USDC).
  autoReturnUsdcMints           String[]
  /// When the destination pubkey was verified (null if not).
  autoReturnDestVerifiedAt      DateTime?
  armSessions ArmSession[] 
}

model Wallet {
  id         Int      @id @default(autoincrement())
  label      String
  publicKey  String   @unique

  // üîª DEPRECATE this ASAP (stop writing plaintext to it)
  privateKey String ?   // make optional later, then drop after migration

  // üîê NEW: envelope-encrypted blob (Argon2id‚ÜíAES-GCM object)
  encrypted  Json?    // stores {v,alg,kdf,{iv1,tag1,pkCipher},{iv2,tag2,dekCipher},aad}

  /// Argon2id hash of the pass-phrase protecting this wallet. If null the
  /// wallet inherits the user's `defaultPassphraseHash`. When non-null the
  /// wallet will only accept this specific pass-phrase on arm. This allows
  /// per-wallet isolation even when a global pass-phrase exists.
  passphraseHash String?

  /// Optional hint to help the user remember the pass-phrase for this wallet.
  /// If null the user‚Äôs global `passphraseHint` may be displayed instead.
  passphraseHint String?

  isProtected Boolean @default(false) // true when using envelope+Arm
  encryptionVersion Int @default(1)   // future-proofing

  createdAt  DateTime @default(now())
  userId     String
  user       User     @relation("UserWallets", fields: [userId], references: [id])

  trades        Trade[]          @relation("WalletTrades")
  closed        ClosedTrade[]
  refreshTokens RefreshToken[]
  tpSlRules     TpSlRule[]
  limitOrders   LimitOrder[]
  dcaOrders     DcaOrder[]
  scheduledStrategies ScheduledStrategy[]
  armSessions ArmSession[] 
  @@unique([userId, label])
}

model AuditLog {
  id        String   @id @default(uuid())
  userId    String
  event     String             // "ARM", "EXTEND", "DISARM", "SIGN"
  meta      Json?
  createdAt DateTime @default(now())

  @@index([userId, createdAt])
}

model Trade {
  id              Int       @id @default(autoincrement())
  mint            String
  tokenName       String?
  entryPrice      Float?
  entryPriceUSD   Float?
  inAmount        BigInt
  outAmount       BigInt
  closedOutAmount BigInt
  exitPrice       Float?
  exitPriceUSD    Float?
  strategy        String
  walletLabel     String?
  txHash          String?   @unique
  unit            String
  slippage        Float?
  decimals        Int?
  usdValue        Float?
  type            String
  side            String
  botId           String
  triggerType     String?
  exitedAt        DateTime?
  timestamp       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt @default(now())
  inputMint       String?  
  outputMint      String? 
  // userId          String?
  // user   User? @relation("UserTrades", fields: [userId], references: [id])
  walletId Int
  wallet   Wallet           @relation("WalletTrades", fields: [walletId], references: [id])
  config   SavedConfigs[] @relation("TradeConfig")
  mevMode        String?
  priorityFee   Int?  
  briberyAmount  Int?   
  mevShared     Boolean  @default(false)
  source          String? 
}

model ClosedTrade {
  id              Int      @id @default(autoincrement())
  mint            String
  tokenName       String?
  entryPrice      Float?
  entryPriceUSD   Float?
  inAmount        BigInt
  outAmount       BigInt
  closedOutAmount BigInt
  exitPrice       Float?
  exitPriceUSD    Float?
  strategy        String
  walletLabel     String?
  txHash          String?  @unique
  unit            String
  slippage        Float?
  decimals        Int?
  usdValue        Float?
  type            String
  side            String
  botId           String
  triggerType     String?
  exitedAt        DateTime
  timestamp       DateTime @default(now())
  walletId Int
  wallet   Wallet @relation(fields: [walletId], references: [id])
}

model SavedConfigs {
  /// Primary key
  id          Int      @id @default(autoincrement())
  /// Owning user (optional)
  userId      Int?
  isSaved     String? 
  /// Name of the saved configuration
  name        String?
  /// Strategy this config applies to
  strategy    String?
  strategyName String? 
  // -----------------------------------------------------------------------
  // Existing config fields (common to many strategies)
  amountToSpend        Float?
  snipeAmount          Float?
  slippage             Float?
  maxSlippage          Float?
  interval             Int?
  maxTrades            Int?
  tokenFeed            String?
  haltOnFailures       Boolean?
  autoSell             Json?
  priorityFeeLamports  Int?
  mevMode              Boolean?
  briberyAmount        Float?
  takeProfit           Float?
  stopLoss             Float?
  takeProfitPct        Float?
  stopLossPct          Float?
  cooldown             Int?
  maxDailyVolume       Float?
  minTokenAgeMinutes   Int?
  maxTokenAgeMinutes   Int?
  minMarketCap         Float?
  maxMarketCap         Float?
  risk                 Float?
  volumeSpikeMultiplier Float?
  // -----------------------------------------------------------------------
  // New general fields shared across multiple strategies
  /// Maximum number of concurrent open trades
  maxOpenTrades        Int?
  /// Enable use of external signals
  useSignals           Boolean?
  /// Maximum hold time for a position in seconds
  maxHoldSeconds       Int?
  /// An array of EMA periods for trend following
  emaPeriods           Json?
  /// Percentage used for trailing stops on trend following
  trailingPct          Float?
  /// Enable the parabolic SAR indicator in trend following
  sarEnabled           Boolean?
  /// Enable pyramiding (adding to winners) in trend following
  pyramidEnabled       Boolean?
  /// Risk percentage for each additional pyramid position
  riskPerAdd           Float?
  /// Maximum cumulative risk allowed in trend following
  maxRisk              Float?
  /// Milliseconds to wait before executing a buy order
  delayBeforeBuyMs     Int?
  /// Percentage for breakout buy threshold (delayed sniper)
  breakoutPct          Float?
  /// Percentage for pullback buy threshold (delayed sniper)
  pullbackPct          Float?
  /// Number of blocks to ignore before executing a trade (delayed sniper)
  ignoreBlocks         Int?
  // -----------------------------------------------------------------------
  // Turbo sniper specific fields
  ghostMode            Boolean?
  coverWalletId        String?
  multiBuy             Boolean?
  multiBuyCount        Int?
  prewarmAccounts      Boolean?
  multiRoute           Boolean?
  autoRug              Boolean?
  useJitoBundle        Boolean?
  jitoTipLamports      Int?
  jitoRelayUrl         String?
  autoPriorityFee      Boolean?
  rpcEndpoints         Json?
  rpcMaxErrors         Int?
  killSwitch           Boolean?
  killThreshold        Int?
  poolDetection        Boolean?
  allowedDexes         Json?
  excludedDexes        Json?
  splitTrade           Boolean?
  tpLadder             Json?
  trailingStopPct      Float?
  turboMode            Boolean?
  autoRiskManage       Boolean?
  privateRpcUrl        String?
  /// Catch-all field for any additional strategy-specific settings not yet modelled
  extras      Json?
  /// Version number for config schema.  When reading configs the loader
  /// should migrate older versions to the latest shape and write back the updated document.
  version     Int      @default(1)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @default(now()) @updatedAt
  trades      Trade[]   @relation("TradeConfig")
  User User[]

}


model StrategyRunStatus {
  id          String   @id @default(uuid())
  botId       String   @unique
  userId      String
  mode        String
  configId    Int?     // FK to StrategyConfig
  pid         Int?
  startedAt   DateTime @default(now())
  pausedAt    DateTime?
  stoppedAt   DateTime?
  isPaused    Boolean  @default(false)
  lastTickAt  DateTime?
  status      String   @default("running")  // running / paused / stopped / completed
  config      Json?
  @@index([userId])
}

model PortfolioTracker {
  id            Int      @id @default(autoincrement())
  startTs       BigInt
  lastMonthlyTs BigInt
  createdAt     DateTime @default(now())
  userId String
  user   User @relation(fields: [userId], references: [id])
}

model NetWorthSnapshot {
  id            Int      @id @default(autoincrement())
  ts            BigInt
  netWorth      Float
  sol           Float
  usdc          Float
  openPositions Int
  createdAt     DateTime @default(now())
  userId String
  user   User @relation(fields: [userId], references: [id])
}

model NetWorthHistory {
  id        Int      @id @default(autoincrement())
  ts        BigInt
  date      String
  minute    String
  value     Float
  createdAt DateTime @default(now())
  userId String
  user   User @relation(fields: [userId], references: [id])
  @@unique([userId, date], name: "userId_date")
}

model LimitOrder {
  id          String    @id @default(uuid())
  type        String    @default("limit")
  token       String
  mint        String
  price       Float
  targetPrice Float
  side        String
  amount      Float
  force       Boolean   @default(false)
  walletLabel String
  walletId    Int
  wallet      Wallet    @relation(fields: [walletId], references: [id])
  userId      String
  user        User      @relation(fields: [userId], references: [id])
  status      String    @default("open")
  tx          String?   // ‚úÖ NEW transaction hash column
  createdAt   DateTime  @default(now())
  executedAt  DateTime? // execution timestamp (if executed)
  @@index([mint])
  @@index([userId])
  @@index([walletLabel])
  @@index([status])
  @@index([walletId])
}

model DcaOrder {
  id            String    @id @default(uuid())
  type          String    @default("dca")
  side          String
  mint          String
  tokenMint     String
  amount        Float
  unit          String
  numBuys       Int
  totalBuys     Int
  frequency     Float
  freqHours     Float
  stopAbove     Float?
  stopBelow     Float?
  walletLabel   String?
  walletId      Int      // ‚úÖ NEW FK
  wallet        Wallet   @relation(fields: [walletId], references: [id])
  userId        String
  user          User     @relation(fields: [userId], references: [id])
  force         Boolean   @default(false)
  amountPerBuy  Float
  completedBuys Int       @default(0)
  executedCount Int       @default(0)
  missedCount   Int       @default(0)
  needsFunding  Boolean   @default(false)
  status        String    @default("active")
  tx            String?
  createdAt     DateTime  @default(now())
  lastBuyAt     DateTime?
  filledAt      DateTime?
  @@index([mint])
  @@index([userId])
  @@index([walletLabel])
  @@index([status])
}

model TpSlRule {
  id          String   @id @default(uuid())
  mint        String
  walletId    Int
  userId      String
  strategy    String
  tp          Float?
  sl          Float?
  tpPercent   Float?
  slPercent   Float?
  sellPct     Int?   
  entryPrice  Float?
  enabled     Boolean  @default(true)
  status      String   @default("active")
  force       Boolean  @default(false)
  failCount   Int      @default(0)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt 
  user   User   @relation(fields: [userId], references: [id])
  wallet Wallet @relation(fields: [walletId], references: [id])
  @@index([mint])
  @@index([userId])
  @@index([strategy])
  // @@unique([userId, walletId, mint, strategy], name: "userId_walletId_mint_strategy")
}

model TelegramPreference {
  id        String   @id @default(uuid())
  userId    String
  chatId String? @unique 
  enabled   Boolean  @default(true)
  types     String[]
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  user User @relation(fields: [userId], references: [id])
  @@unique([userId])
  @@index([chatId])
}

model UserPreference {
  id                 String   @id @default(uuid())
  userId             String   @unique
  context            String   @default("default")
  degenMode          Boolean  @default(false)
  confirmBeforeTrade Boolean  @default(true)
  alertsEnabled      Boolean  @default(true)
  slippage           Float    @default(1.0)
  defaultMaxSlippage        Float    @default(2.0)    
  mevMode     String   @default("fast")     
  defaultPriorityFee        Int      @default(0)       
  briberyAmount      Int      @default(0)         
  autoBuyEnabled     Boolean  @default(false)
  autoBuyAmount      Float    @default(0.0)
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt
  user User @relation(fields: [userId], references: [id])
  @@unique([userId, context])
}

model ScheduledStrategy {
  id          String   @id @default(uuid())
  sortId      Int      @unique @default(autoincrement())
  name        String? 
  mode        String
  config      Json
  launchISO   DateTime
  buyMode     String   @default("interval")
  targetToken String?
  limit       Json?
  /* ‚îÄ‚îÄ‚îÄ FK‚Äôs ‚îÄ‚îÄ‚îÄ */
  walletId    Int
  wallet      Wallet   @relation(fields: [walletId], references: [id])
  userId      String
  user        User     @relation(fields: [userId], references: [id])
  status      String   @default("pending")
  startedAt   DateTime?                   
  finishedAt  DateTime?                   
  /* ‚îÄ‚îÄ‚îÄ meta ‚îÄ‚îÄ‚îÄ */
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  /* ‚îÄ‚îÄ‚îÄ indexes ‚îÄ‚îÄ‚îÄ */
  @@index([launchISO])
  @@index([walletId])
  @@index([userId])
}

model RefreshToken {
  id        String   @id @default(uuid())
  token     String
  userId    String
  createdAt DateTime @default(now())
  user     User    @relation(fields: [userId], references: [id])
  Wallet   Wallet? @relation(fields: [walletId], references: [id])
  walletId Int?
  @@index([token])
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ ArmSession (NEW) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
/// Stores per-session overrides for auto-return at arm time.
model ArmSession {
  id                   Int      @id @default(autoincrement())
  userId               String
  walletId             Int
  autoReturnEnabled    Boolean  @default(false)
  autoReturnDestPubkey String?
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt
  user   User   @relation(fields: [userId], references: [id])
  wallet Wallet @relation(fields: [walletId], references: [id])
  @@index([userId])
  @@index([walletId])
}
